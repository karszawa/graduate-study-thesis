本研究では本研究室で開発されてきた分散アルゴリズムシミュレータH-DASの機能追加と不具合の修正を行った。
この章ではその詳細について述べる。

# 機能追加

## シミュレーション開始時の設定画面の統合 

H-DASは平成18年から開発されてきたソフトウェアである。
そのため、初期のヴァージョンと比べると多数の機能が存在し、シミュレーションの自由度も向上している。
しかし、多くの機能が追加されたことで、シミュレーションを開始する前に設定しなければならない項目も増えてしまった。
今やその項目はプロセス数・プロセスの故障確率・メッセージの通信遅延の上限・コータリーの要否・使用するコータリーの種別・FIFO性の有無の6項目となった(図\ref{fig:presimulation-windows-old})。
このように多くの項目を別個で設定するのはユーザにとって無意味な手間であるし、シミュレーションを開始する際に項目のチェックができないのでミスを生みやすい。
このような事情により、設定画面を統合しユーザがストレスなくシミュレーションを開始できるようにする必要があった。

図\ref{fig:presimulation-window-new}は改良されたシミュレータの統合された設定画面である。
このように、シミュレーションを開始する際の設定項目は一目瞭然となった。

![従来のシミュレータで入力する必要のあったウィンドウの一覧](./src/fig/presimulation-windows-old.eps){width=0.8\linewidth}

![改良されたシミュレータで1つに統合された設定画面](./src/fig/presimulation-window-new.eps){width=0.8\linewidth}

## イベント発生回数の表示

図\ref{fig:simulator-events}はシミュレータの上部を切り取ったものである。
ここに表示されている`# of events: [number]`と書いてあるのがイベント数を表している。
この数値はユーザがプロセスのイベントを実行するか空イベントを実行するかすると1ずつ上昇する。
この数値はユーザの操作のたびに上昇するため、シミュレーションを開始してからどれほどの時間が経過したかを示す一つの目安となる。
この数値を利用すれば、たとえば、実行したシミュレーションを保存しそれを履歴から再実行する際に、この数値を見て動作を確認したい箇所の目算をつけることなどができる。

![シミュレータ上部の\texttt{\#\ of\ events:\ {[}number{]}}はイベントの発生回数を表している。](./src/fig/simulator-events.eps){width=0.8\linewidth}

# 不具合修正

## 大量のイベントの連続発生でプログラムが強制終了する不具合

従来のシミュレータには多数のイベントを生起させ続けるとプログラムが強制終了してしまうという問題があった。
この問題はイベント生起の自動化時に特に顕著で、たとえば、プロセス数を16個に限定しても、30分ほど自動実行させているだけでプログラムが停止してしまうほどであった。
強制終了ではそのときのプロセスの状態なども全くわからないので大変に不便である。

このような不具合が生じる原因は、実行したイベントを初期状態になるまで取り消すことができるという機能にある。
この機能を実現するためにH-DASでは実行されたイベントの情報をすべて主記憶上に記憶している。
そのため、大量のイベントを生起させると主記憶の容量が足りなくなってしまう。
こうして発生したメモリ不足によりプログラムの強制終了が起きてしまうのであった。

この問題を解決するためのアプローチは、1つ1つのイベントが持つ情報量自体を少なくする方法と、
主記憶上に保存するイベントの量を制限し残りは補助記憶に保存するという方法の二通りが考えられる。
本研究では両方の解決法を施すこととし、主記憶上に保存しなければならない情報を制限すると同時に、補助記憶に保存しなければならない情報もなるべく少なくするという方法を取った。

まず各イベントの情報量を削減する方は、イベントが持つプロセスの集合を表すデータ構造を整理することで簡単に実現できた。
もともとプロセスの集合は`java.util.HashSet`として実装されていたが、プロセスには分散システムのプロセス数を$N$として$0$から$N-1$までの連番が振られているので、
データ構造を`java.util.ArrayList`に変更することで、使用するメモリ容量を半分に減らすことができた。
本研究では実施していないが、各イベントが持つイベントを実行する前と後の2つの大域状態の情報をイベントを制御するクラスに持たせることで情報量は更に半分まで減らせる。
これは、あるイベントの持つそれを実行した後の大域状態とそのイベントの次に実行されたイベントが持つ実行前の大域状態は全く同じであるからである。
また、分散システムのプロセスのほとんどはただ1つのイベントを実行しただけでは状態が変化しない。
そのため、状態が変化したプロセスだけを抜き出して保存すれば必要な記憶容量はなおいっそう少なくなる。

次にイベントを補助記憶に書き出す方法だが、これも問題なく実装することができた。
主記憶に保存されるイベントの数は256個とし、それらは`loadedEvents`という表に登録される。
もし生起したイベントの数が256個を超えたら、表にあるイベントのうち登録された時刻が最も古いものから順に補助記憶に書き出される。
イベントの書き出し先はプログラムの実行ディレクトリに作られるdumpディレクトリとした。
プログラム実行中にユーザがdumpディレクトリを削除するなどして補助記憶にあるイベントの情報にアクセスできなくなると、
イベントを取り消したり、シミュレーションの履歴を保存するなどの操作が出来なくなってしまうので注意が必要である。

以上のような改善を施したことで、プログラムが主記憶を使い果たし強制終了することはなくなった。
加えて、イベント自体の情報量を削減したことで、シミュレーションを再実行可能な形式で保存する場合に必要なデータ容量も少なくなった。
この形式はデータのほぼすべてがイベントの集合によるもので占められていたからである。
シミュレーションの結果を保存するのは主記憶ではなく補助記憶なので、プログラムが強制終了するといった重大な問題とはいえないが、
この形式は場合によっては数GBの大きさになることもあり、また複数のシミュレーションが保存される状況が想定されるので、
データ量はなるべく削減するのが好ましい。

## 通信路にFIFO性を付与したときに通信遅延の制約が守られない不具合

H-DASではシミュレーション開始時の設定で選択することによって通信路にFIFO性を付与することができる。
FIFO性を付与した通信路では、プロセス$P_i$からプロセス$P_j$に向けて送信されたメッセージは必ずメッセージの発生順に到着する。
また、H-DASではFIFOの設定と同時に通信遅延の上限も設定する必要がある。
従来のシミュレータでのFIFOを設定した際の通信遅延の決め方は、プロセス$P_i$からプロセス$P_j$に向けて送信されたメッセージの内、
最も後に送信されたメッセージの通信遅延に通信遅延上限以内の正の整数をランダムで選び足し合わせたものを新たな通信遅延とするというものだった。
これでは時刻$t$と時刻$t+1$にプロセス$P_i$からプロセス$P_j$に向けて送信されたメッセージの後者の方は通信遅延が最大$2D-1$($D$を通信遅延上限とする)となってしまい、
通信遅延の制約を満たさない。

この問題は、メッセージの発生順と到着時刻を別々に管理することで解決できた。
この方法では、メッセージ$m$が発生した時刻を$t$、通信遅延上限を$D$とし、メッセージの発生と同時に$t_m=t+d(1<=d<=D)$という値を生成し、
$m$は待ち行列$Q_{message}$に、$t_m$は優先度付き待ち行列$Q_{time}$(小さい値が優先される)にそれぞれ保存する。
ある時刻にプロセスに到着するべきメッセージがあるかどうかは$Q_{time}$の先頭の値を見て判断し、
もしあるならば$Q_{message}$からメッセージを取り出してプロセスに届ける。
このとき$Q_{time}$からも先頭の値を取り除く。
このようにすると、メッセージはその発生順に$Q_{message}$から取り出されるので通信路のFIFO性は保証される。
また、メッセージ$m_i$が$Q_{message}$の先頭から$i$番目にあるとすると、$Q_{time}$の$i$番目の値$t_i$は、
$m_i$が発生すると同時に生成された値よりも小さくなることはあっても大きくなることはありえない。
したがって、通信遅延上限の制約も満たされる。

図\ref{fig:fifo-delay-constraint}にプロセス$P_i$から$P_j$に向けて送られるメッセージの様子を示す。

![プロセス$P_i$からプロセス$P_j$に向けて送られるメッセージの様子](./src/fig/fifo-delay-constraint.eps){width=0.8\linewidth}

<!-- 同時刻に複数のメッセージが到着してしまう問題の解決 -->

## 大量のプロセスからなるシステムをシミュレートする際に実行速度が極度に低下する不具合 

従来のシミュレータではプロセス数が多くなると実行速度が極端に低下する問題があった。
プロセス数が多くなればなるほどイベントの実行毎にしなければならない処理が増えるので、これはある程度までは当然の動作であるのだが、
従来のシミュレータのそれはあまりに極端なものであった。

この問題は自動実行時にイベントを実行するプロセスの選択方法に原因があった。
その選択方法とは、分散システム上のすべてのプロセスからランダムでプロセスを選択し、
そのプロセスに実行できるイベントがあればそれを実行するというものであった。
実行するアルゴリズムにもよるが、これは大変に非効率的である。
なぜならプロセスの状態によっては実行できるイベントが1つもない場合もあるからである。
もし、分散システム上の多くのプロセスで実行できるイベントが1つもなかった場合、
何度も何度もイベントを実行するプロセスの抽選を行うことになり、無駄に時間がかかってしまう。

この問題は予めイベントを実行できるプロセスを抽出し、条件を満たすプロセスが1つもなければ何も実行せず、
そのようなプロセスが存在すればそれらの中から選出を行うことで解決できた。

## 特定の環境でプロセスの色付けがなされない不具合

H-DASではプロセスを表すセルをプロセスの状態によって色付けするという機能があり、これは複数のプロセスの状態をひと目で判別でき、便利である。
しかし従来のシミュレータでは特定の環境で色付けがなされないという問題があった。
H-DASはJavaの実行環境のあるすべてのマシンで実行される可能性があると想定しているので、この不具合を修正する必要があった。

結論から言うと、この問題の原因は`javax.swing.JComponent`クラスの`opaque`フラグにあった。
このフラグはコンポーネントの背景を透過するかどうかを表している。
シミュレータのセルは`javax.swing.JButton`クラスで表現しているが、一部の環境では`opaque`フラグがデフォルトで`false`になっているようだった。

この問題はセルの初期化時に`opaque`フラグを`true`に設定することで簡単に解決できた。
問題の解決前と解決後のシミュレータの画面を図\ref{fig:cell-opaque}に示す。

![シミュレータの画面](./src/fig/cell-opaque.eps){width=0.8\linewidth}
